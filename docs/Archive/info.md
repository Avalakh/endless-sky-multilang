Проблема с выводом описаний на экране планеты:
1. планеты (открывается при посадке, загрузке когда на планете и при клике на изображение на экране планеты). 
2. космопорта (открывается когда нажимаешь на кнопку "Spaceport").

Кратко по ситуации и что сделано.
Что видно по логу
Перевод для описания планеты находится и возвращается (221 символ). Значит, проблема не в ключах и не в загрузке ru.json, а в отрисовке этого текста.
При запуске из сборки (например, build/mingw/Debug) игра ищет data рядом с exe. Нужно, чтобы в этом data были и lang/ru.json, и fonts/ с выбранным .ttf. Проверены пути к файлам, файлы на месте. Весь остальной русский текст выводится нормально - со шрифтом все хорошо.

При нажатии на кнопки "Торговля", "Банк", "Экипаж" вывод на эту же панель (или такую же панель на этом же месте) поизводится нормально. В английском тексте выводится нормально.

---

## Анализ и решение

**Гипотеза частично верна, но неточна.**

Верно: только описания планеты и космопорта используют `TextArea` (с внутренним `WrappedText`), тогда как Торговля/Банк/Экипаж рисуют текст напрямую через `font.Draw`. Именно поэтому только описания не отображаются.

**Неточность:** проблема не в `RenderBuffer` и не в `Font.Draw` — они работают корректно. Настоящая причина — в `WrappedText::Wrap()`.

---

**Истинная причина: знаковое сравнение `char` с байтами UTF-8 в `WrappedText::Wrap()`.**

В файле `source/text/WrappedText.cpp`, функция `Wrap()`, строка 243:

```cpp
const char c = *it;
// ...
if(c <= ' ' && traversingWord)   // строка 246
// ...
else if(c <= ' ')                // строка 281
```

На всех распространённых платформах тип `char` — **знаковый**. Байты UTF-8 кириллических символов находятся в диапазоне `0x80–0xD1` (например, 'Д' = `0xD0 0x94`). Будучи знаковым `char`, эти значения становятся **отрицательными** (от -128 до -1). Условие `c <= ' '` (то есть `c <= 32`) **истинно для всех отрицательных значений**.

**Последствия для русского текста:**
- Каждый байт кириллического символа воспринимается как пробельный символ.
- Ветка `else if(!traversingWord)` (начало нового слова) **никогда не достигается**.
- Вектор `words` остаётся **пустым**.
- `WrappedText::Draw()` сразу выходит: `if(words.empty()) return;`.
- **Ничего не отрисовывается.**

Для ASCII-текста (английского) байты `0x41–0x7E` — положительные, условие `c <= ' '` не срабатывает, слова обнаруживаются корректно. Поэтому английский текст в `TextArea` работает.

---

**Решение: приводить `c` к `unsigned char` перед сравнением.**

Файл: `source/text/WrappedText.cpp`, функция `WrappedText::Wrap()`.

Изменено:
```cpp
// БЫЛО:
const char c = *it;

// СТАЛО:
const unsigned char c = static_cast<unsigned char>(*it);
```

Также добавлен явный каст в вызове `Space(static_cast<char>(c))`, так как функция `Space` принимает `char`.

При `unsigned char` байты `0x80–0xFF` имеют значения 128–255, которые **больше** `' '` (32). Они перестают восприниматься как пробелы, ветка `else if(!traversingWord)` корректно срабатывает на первом байте каждого кириллического слова, и `words` заполняется правильно.
