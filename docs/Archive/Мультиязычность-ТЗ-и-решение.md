# Мультиязычность (i18n): проблематика и решение

Единый документ: техническое задание по выносу текста в локали и спецификация по корректному отображению UTF-8 (кириллица и др.) в игре Endless Sky.

---

## 1. Цели и область

**Цели:**
- Перевести проект на мультиязычную модель: убрать пользовательский текст из кода и данных в виде литералов, заменить на ссылки (ключи), текст хранить в отдельных JSON-файлах по языкам.
- Обеспечить корректное отображение строк в UTF-8 (кириллица, диакритика) во всех экранах игры.

**Область:**
- **В рамках ТЗ:** текст, захардкоженный в исходном коде C++ (UI, сообщения, подсказки, форматы дат и т.д.); исправление рендеринга шрифта для UTF-8.
- **Опционально / отдельная фаза:** текст в data-файлах (`data/_ui/messages.txt`, `interfaces.txt`, `tooltips.txt`, `help.txt` и т.д.) — вынос в JSON с сохранением ключей или миграция формата.

**Результат:** один и тот же бинарник и набор data-файлов показывают интерфейс на разных языках в зависимости от выбранной локали; добавление языка = добавление/правка JSON без правки C++ и без перекомпиляции; выбранный язык отображается без «кракозябр» (в т.ч. кириллица).

---

## 2. Проблематика

### 2.1. Текст в C++ (source/)

- Строковые литералы разбросаны по десяткам файлов:
  - **Preferences.cpp:** опции («Escorts expend ammo», «dd/mm/yyyy», «windowed», «fullscreen», названия громкости и т.д.).
  - **BankPanel.cpp:** заголовки таблиц («Type», «Principal», «Interest»), подписи («Your credit score is …»).
  - **GamerulesPanel.cpp:** названия правил («Minimum value», «Grace period», …), сообщения валидации.
  - **AI.cpp, Engine.cpp:** сообщения для игрока («ship»/«ships», «No formations available», «Landing on:» и т.д.).
  - **Date.cpp:** короткие названия дней («Sat», «Sun», …).
  - **ConversationPanel.cpp:** метки («[done]», «[ok]», «Name:»).
  - **ItemInfoDisplay.cpp, OutfitterPanel.cpp, ShipInfoDisplay.cpp:** шаблонные фразы («outfit»/«ship», «To purchase this …»).
  - **MainPanel, MissionPanel, PlanetPanel, LoadPanel и др.:** диалоги и подсказки.
- Нет единого API для «перевода по ключу»; нет загрузки внешних строк из JSON/файлов локали.

### 2.2. Текст в data/

- **data/_ui/messages.txt:** уже есть ключи (`message "no formations available"`) и поле `text "…"` — текст отображаемый. Для i18n текст «…» нужно забирать из JSON по ключу.
- **data/_ui/interfaces.txt:** элементы с `label`, `string`, `button` — строки интерфейса. Аналогично: в i18n — ключ в данных, строка из JSON.
- **data/_ui/tooltips.txt, help.txt, landing messages.txt и т.д.:** тот же принцип — идентификатор + текст; текст можно вынести в JSON.
- Контент (миссии, диалоги, описания кораблей/аутфитов) в `data/*.txt` — большой объём; в данном ТЗ фокус на интерфейсе и системных сообщениях, контент может быть отдельной фазой.

### 2.3. Отображение текста: шрифт и UTF-8

**Причина:**  
Шрифт в игре (`source/text/Font.cpp`) рисует текст побайтово и считает символом один байт: `glyph = c - 32` (см. `Font::Glyph(char c, ...)` и цикл `for(char c : str)` в `DrawAliased`). Поддерживается по сути только ASCII (98 глифов, `GLYPHS = 98`). Строки в UTF-8 (кириллица в `ru.json`) — многобайтовые; каждый байт попадает в глиф отдельно, из‑за чего отображаются неверные символы (Π, пустые места и т.п.). Чтобы выводить нужный текст на нужном языке, требуется не побайтовая интерпретация, а разбор строки как последовательности символов (кодовых точек UTF-8) и отображение каждого символа по маппингу «кодовая точка → глиф» с использованием байтов/индексов глифов из атласа выбранного языка.

**Итог:** без двух частей решения (вынос строк в локали + поддержка UTF-8 в шрифте) мультиязычность не достигается: либо текст остаётся в коде, либо переведённый текст отображается некорректно.

---

## 3. Решение. Часть A: архитектура мультиязычности (ключи и локали)

### 3.1. Общий подход

1. **В коде:** вместо литерала используется вызов функции получения строки по ключу, например `tr("prefs.expend_ammo")` или `i18n::Get("prefs.expend_ammo")`.
2. **Тексты:** хранятся в JSON-файлах по одному на язык (например `lang/en.json`, `lang/ru.json`). Ключ в коде совпадает с ключом в JSON.
3. **Загрузка:** при старте приложения (или при смене языка) загружается выбранный JSON в глобальное хранилище (или в `GameData`); при отсутствии ключа — fallback на ключ по умолчанию (например `en`) или на сам ключ.

### 3.2. Размещение файлов и выбор языка

- **Каталог локалей:** например `data/lang/` (рядом с остальными data) или `lang/` в корне репозитория.
- **Имена файлов:** `en.json`, `ru.json`, `de.json` и т.д. (код языка по ISO 639-1 или 639-2).
- **Язык по умолчанию:** `en`; при отсутствии файла или ключа — использовать `en.json`, затем при отсутствии ключа — выводить ключ как строку (для отладки).
- **Источник выбора языка:** конфиг/настройки пользователя (например, существующий `preferences.txt` или отдельный ключ в настройках). При первом запуске — автоопределение системной локали (опционально) или `en`.

### 3.3. Формат JSON

Плоский объект «ключ → строка» для простоты и быстрого доступа:

```json
{
  "prefs.expend_ammo": "Escorts expend ammo",
  "prefs.frugal_escorts": "Escorts use ammo frugally",
  "prefs.date_dmy": "dd/mm/yyyy",
  "prefs.date_mdy": "mm/dd/yyyy",
  "prefs.date_ymd": "yyyy-mm-dd",
  "prefs.screen_windowed": "windowed",
  "prefs.screen_fullscreen": "fullscreen",
  "bank.heading_type": "Type",
  "bank.heading_principal": "Principal",
  "bank.credit_score": "Your credit score is {{value}}.",
  "gamerules.depreciation_min": "Minimum value",
  "message.no_formations": "No formations available.",
  "date.day_sat": "Sat",
  "date.day_sun": "Sun"
}
```

- **Ключи:** строчные, разделитель — точка (например `prefs.*`, `bank.*`, `message.*`, `date.*`), без пробелов.
- **Значения:** строка в UTF-8. Для подстановок — плейсхолдеры в едином формате, например `{{value}}`, `{{count}}`.
- **Максимальная длина строки:** если строка выводится в области с ограниченной шириной (кнопка, колонка таблицы, подпись и т.п.) и может быть обрезана движком (`TruncateText` и аналоги), в JSON-файле с языковыми данными для такого ключа нужно указать максимально допустимую длину (в символах или в пикселях). Это позволяет переводчикам укладываться в лимит и избегать нечитаемого обрезания. Варианты хранения: отдельный объект в том же файле, например `"_maxLength": { "prefs.expend_ammo": 25, "bank.heading_type": 12 }`, либо объект-значение вида `"key": { "text": "…", "maxLength": 25 }` для ключей с ограничением; для остальных ключей — по-прежнему строка.
- Все файлы — UTF-8 без BOM. При ошибке парсинга JSON — загрузка fallback-локали или вывод ошибки в лог и использование ключей как строк.

### 3.4. Модуль локализации и API (C++)

- **Файлы:** например `source/text/Translation.h`, `source/text/Translation.cpp` (или `source/I18n.h`, `source/I18n.cpp`).
- **Функционал:**
  - Загрузка одного выбранного JSON в `map<string, string>` (или аналог).
  - Функция получения строки по ключу: `const string &Tr(const string &key)` или `string Tr(const string &key)`.
  - При отсутствии ключа: попытка загрузки fallback-локали (en), затем возврат ключа как строки.
  - Установка текущего языка: `SetLanguage(const string &code)` (перезагрузка JSON).
- **API:** один основной вызов, например `Tr("prefs.expend_ammo")` → `"Escorts expend ammo"`. Опционально: `Tr("bank.credit_score", {{"value", to_string(score)}})` для подстановок.
- **Подстановки:** в JSON допускаются плейсхолдеры `{{name}}`, `{{value}}`, `{{count}}`; в коде — замена `{{key}}` на соответствующее значение.
- **Множественное число:** отдельные ключи `ship_one` / `ship_many` и выбор в коде по счётчику или один ключ с параметром и функция выбора формы — в рамках второй итерации при необходимости.

### 3.5. Точки внедрения и инвентаризация ключей

- Заменить каждый пользовательский строковый литерал в: `Preferences.cpp`, `PreferencesPanel.cpp`, `BankPanel.cpp`, `BoardingPanel.cpp`, `GamerulesPanel.cpp`, `AI.cpp`, `Engine.cpp`, `Date.cpp`, `ConversationPanel.cpp`, `MainPanel.cpp`, `MissionPanel.cpp`, `PlanetPanel.cpp`, `LoadPanel.cpp`, `HailPanel.cpp`, `ItemInfoDisplay.cpp`, `OutfitterPanel.cpp`, `ShipInfoDisplay.cpp`, `OutfitInfoDisplay.cpp` и остальных файлах, где выводятся строки пользователю.
- Не трогать: технические строки (имена файлов, теги, ключи парсера), логи, отладочный вывод (если не требуется их перевод).
- **Порядок работ:** составить полный список строк для перевода; исключить не показываемые пользователю; присвоить ключи по схеме `раздел.краткое_описание` (латиница, нижний регистр); создать `lang/en.json`; в коде заменить литералы на `Tr("key")`.
- **Соглашение по ключам:** префиксы `prefs.`, `bank.`, `gamerules.`, `message.`, `date.`, `ui.`, `dialog.`, `mission.`, `hail.` и т.д.

### 3.6. Data-файлы (опциональная фаза)

- **messages.txt:** оставить только ключи; текст брать из `lang/<locale>.json` по ключу при загрузке сообщений.
- **interfaces.txt:** значения `label`, `string`, `button` трактовать как ключ перевода и при отрисовке подставлять `Tr(value)`; при отсутствии ключа — показывать значение как есть.
- **Tooltips, help, landing messages:** идентификатор = ключ; текст из JSON с ключами вида `tooltip.*`, `help.*`, `landing.*`.

### 3.7. Загрузка JSON

- **Момент:** после инициализации путей (Files), до отрисовки первого кадра. При смене языка в настройках — перезагрузить выбранный JSON.
- **Парсинг:** использовать существующую зависимость (например nlohmann/json) или минимальный парсер «ключ–строка».
- **Путь:** например `Files::Resources() + "lang/" + languageCode + ".json"`.

---

## 4. Решение. Часть B: поддержка UTF-8 в шрифте

Цели и не-цели:

| Цели | Не входят в scope |
|------|-------------------|
| Корректное отображение строк в UTF-8 (кириллица, диакритика) во всех экранах игры. | Поддержка RTL, сложных скриптов (арабский, тайский и т.д.) без отдельного ТЗ. |
| Сохранение текущего API `Font::Draw(string)`, `Width(string)` по возможности без ломающих изменений. | Смена формата хранения локалей (JSON остаётся). |
| Один или несколько шрифтовых атласов для выбранных языков. | Динамическая подгрузка шрифтов из интернета. |

### 4.1. Текущее состояние Font

- **Font** (`source/text/Font.cpp`, `Font.h`): текстура — одна картинка с 98 глифами в ряд. `Glyph(char c, bool isAfterSpace)`: индекс глифа как `max(0, min(GLYPHS-3, c - 32))`. Отрисовка и ширина: итерация по `str` как по байтам (`for(char c : str)`, `WidthRawString(const char *str)`).
- Шрифты загружаются в `GameData.cpp`: `FontSet::Add(Files::Images() / "font/ubuntu14r.png", 14)` и аналогично для 18.
- Локали: `Translation` уже отдаёт строки в UTF-8 (в т.ч. раскодирование `\uXXXX`). Проблема только в рендеринге.

### 4.2. Технический дизайн: UTF-8 в Font + расширенный атлас

Декодировать UTF-8 в кодовые точки (code point); один атлас с глифами для ASCII и выбранного набора символов (например кириллица). Маппинг code point → индекс глифа.

**Декодирование UTF-8**

- Ввести итерацию по **кодовым точкам** (uint32_t), а не по байтам.
- Вспомогательная функция в пространстве имён `text` или внутри `Font`: чтение следующей кодовой точки из `const char*` / `string`, сдвиг указателя; обработка невалидного UTF-8 (подстановка U+FFFD или пропуск).
- Все места обхода строки по байтам (`DrawAliased`, `WidthRawString`, расчёт ширины в `TruncateText` и т.д.) перевести на обход по кодовым точкам.

**Маппинг code point → глиф**

- Ограниченный набор: ASCII 32–126 + блок кириллицы (например U+0400–U+04FF), при необходимости расширение латиницы (диакритика).
- Структура данных: `std::unordered_map<uint32_t, int>` или массив для плотного диапазона с значением «нет глифа». Индекс глифа используется как сейчас для `glUniform1i(glyphI, glyph)` и кернинга; число глифов в атласе (GLYPHS) увеличивается под новый атлас (например 98 + 256 для кириллицы или отдельная сетка 16×N).

**Атлас и загрузка**

- Формат текстуры: сетка глифов (например первая строка — ASCII, вторая — кириллица) или один длинный ряд с увеличенным `GLYPHS`.
- В `Font::Load`: задать маппинг code point → индекс в атласе. Fallback: если кодовая точка не найдена — рисовать один «unknown» глиф (квадрат или пробел).

**Обратная совместимость и API**

- Сигнатуры `Draw(const string &str, ...)`, `Width(const string &str, ...)` оставить; внутренне строка интерпретируется как UTF-8. Существующие вызовы с чисто ASCII работают без изменений.
- `TruncateText`, `WrappedText`: разбиение по словам не должно резать UTF-8 посередине кодовой точки; ширина считается по глифам (кодовым точкам).

**Кернинг**

- При расширении атласа сохранить формулу по индексам глифов в новой сетке или упростить кернинг для не-ASCII (фиксированный шаг), чтобы не раздувать размер `advance[]`.

### 4.3. Затрагиваемые файлы (Font / UTF-8)

| Файл / модуль | Изменения |
|---------------|-----------|
| `source/text/Font.cpp` | UTF-8 декодер; обход по кодовым точкам в `DrawAliased`, `WidthRawString`; `Glyph(char)` заменить/дополнить на `Glyph(uint32_t codepoint)` с маппингом; при необходимости пересчёт кернинга под новый размер атласа. |
| `source/text/Font.h` | Объявление маппинга/метода для глифа по code point; при расширенном атласе — константа/конфиг размера сетки глифов. |
| Ресурсы (`images/font/`) | Новые файлы атласа с кириллицей (и при необходимости диакритикой) или конфиг с маппингом code point → клетка в атласе. |
| Truncate / логика в Font | Truncate должен учитывать длину в символах (кодовых точках) или в ширине, а не в байтах. |
| `source/text/WrappedText.cpp` | При переносе не резать UTF-8 посередине кодовой точки. |
| Остальные панели | Без изменений API; по мере готовности шрифта убрать точечные `SetDisplayLanguageOverride("en")`. |

### 4.4. Порядок задач (UTF-8)

1. UTF-8 декодер: чтение следующей кодовой точки из `const char*`, тесты на корректных и битых последовательностях.
2. Маппинг и атлас: формат атласа, изображение с кириллицей; загрузка маппинга code point → индекс глифа; fallback для неизвестных символов.
3. Font: ввести `Glyph(uint32_t)` и заменить циклы в `DrawAliased` и `WidthRawString` на итерацию по кодовым точкам; маппинг и кернинг.
4. Ширина и обрезка: `TruncateText` и `FormattedWidth` считают ширину по глифам; обрезка по границе символа, а не байта.
5. WrappedText: проверка границ при переносе (не резать UTF-8 внутри символа).
6. Регрессия и локали: прогон с en/ru; снятие или сужение использования `SetDisplayLanguageOverride`.

---

## 5. Этапы реализации (сводка)

| Этап | Содержание | Результат |
|------|------------|-----------|
| 1 | Модуль локализации: загрузка JSON, `Tr(key)`, fallback на en, выбор языка из настроек | Можно получать строку по ключу из JSON |
| 2 | Инвентаризация строк в C++, создание `lang/en.json`, замена литералов на `Tr(...)` в приоритетных экранах (Preferences, Bank, Main menu) | Часть UI переведена на ключи |
| 3 | Остальные экраны и сообщения в C++ | Весь код переведён на ключи |
| 4 | UTF-8 в Font: декодер, атлас с кириллицей, маппинг code point → глиф, обход по кодовым точкам | Корректное отображение ru (и др. UTF-8) |
| 5 | Интеграция с data: messages.txt / interfaces.txt (ключ → Tr при отображении) | Опционально |
| 6 | Второй язык (ru.json), тесты, документация для переводчиков | Готовность к мультиязычности |

---

## 6. Критерии приёмки

- В коде нет пользовательских строковых литералов, отображаемых игроку; вместо них — ключи и вызов `Tr(...)`.
- Тексты интерфейса и системных сообщений хранятся только в `lang/*.json`.
- Смена языка в настройках меняет отображаемый язык без перекомпиляции.
- При отсутствии ключа в текущей локали используется fallback (en), затем при отсутствии и там — вывод ключа (для отладки).
- Добавление нового языка = добавление нового JSON-файла и пункта в настройках; код не меняется.
- При выбранном русском языке все строки из `ru.json` отображаются читаемо (кириллица без «кракозябр» и пустых мест).
- Английская локаль и чисто ASCII-строки ведут себя как до изменений (кернинг, переносы).
- Строки с невалидным UTF-8 или неподдерживаемыми символами не приводят к падению; отображается fallback-глиф или пробел.

---

## 7. Риски и ограничения

| Риск | Митигация |
|------|-----------|
| Большой объём правок в `source/` | Замены поэтапно с тестами. |
| Динамические строки («X ships will …») | Шаблоны с плейсхолдерами или отдельные ключи и склейка в коде; дисциплина в именовании. |
| Длина и вёрстка при переводе | Проверка вёрстки для нескольких языков (ru, de). Для строк, которые могут обрезаться, в JSON указывать максимальную длину (см. п. 3.3). |
| Контент (миссии, диалоги) | В ТЗ не входит автоматический вынос всего контента в JSON; при необходимости — отдельный проект. |
| Увеличение размера текстуры и кернинга | Ограничить набор глифов (нужные блоки Юникода); fallback для редко используемых символов. |
| Регрессия производительности Font | Итерация по кодовым точкам и маппинг по массиву/хэшу — O(1), сравнимый объём работы. |

---

## 8. Файлы для создания/изменения (сводка)

**Создать:**
- `source/text/Translation.h`, `source/text/Translation.cpp` (или выбранные имена).
- `data/lang/en.json` (и при необходимости `ru.json` и др.).
- Ресурсы: новые изображения атласа шрифта с кириллицей (и при необходимости конфиг маппинга).
- Документ для переводчиков: формат JSON, список ключей, правила подстановок.

**Изменить:**
- `CMakeLists.txt` — добавление новых исходников и копирование `data/lang/*.json` в установку.
- Файлы настроек (загрузка/сохранение выбранного языка).
- Все перечисленные в п. 3.5 исходные файлы с заменой литералов на `Tr("key")`.
- `source/text/Font.cpp`, `source/text/Font.h` — UTF-8, кодовые точки, маппинг, атлас.
- При необходимости: `source/text/WrappedText.cpp`, логика обрезки текста.

**Ссылки на код (для реализации):**
- Отрисовка побайтово: `source/text/Font.cpp` — цикл `for(char c : str)` в `DrawAliased`, `Glyph(char c, ...)`.
- Ширина: `WidthRawString`, вызовы из `Width`, `FormattedWidth`, `TruncateText`.
- Загрузка шрифтов: `source/GameData.cpp` — `FontSet::Add(..., 14)` и `18`.
- Переопределение языка: `source/text/Translation.cpp` (`SetDisplayLanguageOverride`), `source/PreferencesPanel.cpp` (вызовы в `DrawSettings`).

---

*Документ объединяет ТЗ по мультиязычности (ключи, JSON, Tr) и спецификацию по поддержке UTF-8 в шрифте (декодер, атлас, кодовые точки) для проекта Endless Sky (C++, data/*.txt).*
