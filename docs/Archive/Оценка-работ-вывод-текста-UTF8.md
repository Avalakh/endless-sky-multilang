# Оценка работ: переход вывода текста с ASCII на UTF-8

Оценка объёма работ **только** по изменению способа вывода текста в интерфейсе (интерпретация строк как UTF-8 и отрисовка по кодовым точкам). Не входит: вынос строк в локали, ключи перевода, смена языка, JSON-файлы локалей.

**Цель этапа:** чтобы любой уже имеющийся или будущий текст в UTF-8 (в т.ч. кириллица) отображался корректно, без «кракозябр». Это подготовка к последующей мультиязычности, а не сама мультиязычность.

---

## 1. Текущее состояние

- **Font** (`source/text/Font.cpp`, `Font.h`): отрисовка и ширина строки считаются **побайтово**. Символ = один байт; индекс глифа: `c - 32` (до 98 глифов). Строка в UTF-8 (несколько байт на символ) интерпретируется неверно.
- **Шрифт:** одна текстура с 98 глифами в ряд (ASCII-диапазон). Кернинг: матрица `advance[98*98]`.
- **Обрезка текста:** `TruncateBack`, `TruncateFront`, `TruncateMiddle` опираются на `str.substr(..., charCount)` — по сути по количеству **байт**, что для UTF-8 даёт обрезку посередине символа.
- **Перенос строк:** `WrappedText` итерирует текст побайтово; границы слов определяются по пробельным байтам — для UTF-8 этого достаточно, если измерение ширины и отрисовка в `Font` будут по кодовым точкам.

---

## 2. Что нужно сделать (без расширения атласа)

Минимальный объём — без добавления новых глифов (кириллица и т.д.): только корректная интерпретация UTF-8 и обход по кодовым точкам. Неподдерживаемые символы (все не-ASCII при текущем атласе) можно отображать одним fallback-глифом (например пробел или «?»).

| Задача | Описание |
|--------|----------|
| UTF-8 декодер | Функция: из `const char*` (и опционально длины/конца) получить следующую кодовую точку (uint32_t) и сдвинуть указатель. Обработка невалидного UTF-8 (U+FFFD или пропуск). |
| Font: обход по кодовым точкам | Заменить циклы по `char` на циклы по кодовым точкам в `DrawAliased` и `WidthRawString`. |
| Font: маппинг code point → глиф | Вместо `Glyph(char c)` — `Glyph(uint32_t codepoint)`: для 32–126 — как сейчас (индекс `codepoint - 32`), для остальных — индекс fallback-глифа. Спецсимволы кавычек оставить. |
| Truncate по границам символов | Обрезка «по N символов» и измерение ширины вести по кодовым точкам; не резать UTF-8 посередине байтов. |
| WrappedText | Проверить, что границы слов и индексы не ломают UTF-8 (пробельные символы — однобайтовые); при необходимости явно переходить к следующей кодовой точке при обходе. |

---

## 3. Затрагиваемые файлы и объём правок

| Файл | Оценка изменений |
|------|-------------------|
| **source/text/Font.cpp** | UTF-8: чтение следующей кодовой точки (внутри файла или вызов утилиты). Замена цикла в `DrawAliased` (~25 строк) на итерацию по кодовым точкам. Замена цикла в `WidthRawString` (~20 строк). Замена/дополнение `Glyph(char)` на `Glyph(uint32_t)` с маппингом (~15 строк). В `TruncateEndsOrMiddle` и вспомогательных: обрезка по кодовым точкам, а не по байтам — переписать бинарный поиск/подстроки (~40–50 строк). Инициализация `widthEllipses` и параметр `after` в `WidthRawString`: передавать code point. **Итого по файлу: ~120–150 строк правок/добавлений.** |
| **source/text/Font.h** | Объявление: `Glyph(uint32_t codepoint, bool isAfterSpace)` (или перегрузка), при необходимости константа для fallback-глифа. **~5–10 строк.** |
| **source/text/WrappedText.cpp** | Текущая логика (пробел/таб/перевод строки = однобайтовые) при UTF-8 сохраняется. Рекомендуется при обходе символов внутри слова переходить к следующей кодовой точке, а не к следующему байту, чтобы `word.index` всегда указывал на начало кодовой точки (иначе при будущем расширении атласа возможны баги). **~15–25 строк** (итерация по кодовым точкам в цикле разбора слов). |
| **Утилита UTF-8 (новый файл или namespace в text/)** | Декодер: следующая кодовая точка, проверка валидности. Опционально: «длина в кодовых точках», «подстрока по границам кодовых точек». **~60–80 строк** (один небольшой .cpp + объявления в .h). |

**Итого:** 3–4 файла (включая один новый для UTF-8), ориентировочно **200–270 строк** кода (новый + правки).

---

## 4. Оценка трудозатрат (человеко-дни)

| Этап | Описание | Оценка |
|------|----------|--------|
| 1. UTF-8 утилита | Декодер + тесты на валидном/невалидном UTF-8 | 0.5–1 дн. |
| 2. Font: кодовые точки и маппинг | Glyph(codepoint), DrawAliased и WidthRawString по кодовым точкам, fallback-глиф | 1–1.5 дн. |
| 3. Truncate по символам | TruncateBack/Front/Middle и TruncateEndsOrMiddle без разрыва UTF-8 | 1–1.5 дн. |
| 4. WrappedText | Проверка границ и при необходимости итерация по кодовым точкам | 0.5 дн. |
| 5. Регрессия и краевые случаи | Прогон с ASCII, UTF-8 (например кириллица), невалидный UTF-8; подгонка кернинга/параметра `after` | 1–1.5 дн. |

**Суммарно: 4–6 человеко-дней** (один разработчик, с учётом сборки, прогона тестов и правок по регрессии).

---

## 5. Риски и ограничения

- **Без нового атласа** кириллица и прочие не-ASCII по-прежнему не будут отображаться «нормальными» буквами — только fallback-глиф. Зато не будет некорректной интерпретации байтов как разных ASCII-символов (кракозябр). Полноценное отображение кириллицы потребует отдельного этапа: расширенный атлас + маппинг блоков Юникода (см. раздел 4 документа «Мультиязычность-ТЗ-и-решение»).
- **Кернинг:** параметр `after` в `Width()` сейчас передаётся как `char`; при переходе на code point нужно передавать code point следующего символа (или оставить только пробел по умолчанию).
- **Производительность:** итерация по кодовым точкам и маппинг в таблицу/функцию — того же порядка, что и побайтовый обход; заметной деградации не ожидается.

---

## 6. Зависимости и порядок работ

1. Реализовать UTF-8 декодер и (при необходимости) хелперы для подстрок по границам символов.
2. Ввести `Glyph(uint32_t)` и перевести `DrawAliased` и `WidthRawString` на кодовые точки.
3. Перевести обрезку текста (Truncate*) на учёт границ UTF-8.
4. При необходимости подправить `WrappedText`.
5. Регрессионное тестирование и правки.

После этого этап мультиязычности (ключи, локали, смена языка) и добавление атласов с кириллицей/диакритикой можно делать отдельно, без переделки базового механизма вывода.

---

## 7. Краткая сводка

| Метрика | Значение |
|---------|----------|
| Файлов изменить/добавить | 3–4 |
| Строк кода (оценка) | ~200–270 |
| Человеко-дней | 4–6 |
| Область | только вывод текста (Font, Truncate, WrappedText, UTF-8 утилита) |
| Не входит | локали, ключи перевода, новые глифы/атласы |

Документ подготовлен на основе анализа `source/text/Font.cpp`, `Font.h`, `WrappedText.cpp`, `Truncate.h` и спецификации раздела 4 документа «Мультиязычность-ТЗ-и-решение».

---

---

# Оценка полной (кардинальной) переработки вывода текста

Ниже — оценка **радикальной** переделки подсистемы вывода текста: не точечные правки под UTF-8, а смена архитектуры (расширенные атласы и/или переход на библиотеку рендеринга). Оценки даны в человеко-днях и по объёму кода/файлов.

---

## 8. Масштаб текущего использования текста

- **Файлов, обращающихся к Font/FontSet/Draw/Width:** ~45 (панели, Engine, Interface, Table, MapPanel, OutfitterPanel, BankPanel и др.).
- **Ядро вывода:** `Font`, `FontSet`, `WrappedText`, `Table`, `DisplayText`, `Truncate`, шейдеры `font.vert`/`font.frag`. Загрузка шрифтов в `GameData.cpp`.
- **Жёсткая привязка:** в `font.vert` зашито `98.f` (число глифов); в `Font.cpp` — `GLYPHS = 98`, матрица кернинга `advance[98*98]`, расчёт UV из индекса глифа.

Цель кардинальной переработки: сохранить по возможности публичный API (`Font::Draw`, `Font::Width`, `FontSet::Get(size)`), чтобы не трогать десятки панелей, а изменить только реализацию и ресурсы.

---

## 9. Варианты кардинальной переработки

### Вариант A: Расширенная bitmap-модель (UTF-8 + большие атласы, без сторонних библиотек)

**Суть:** оставить отрисовку из bitmap-атласа, но ввести UTF-8, увеличенное число глифов (например 98 + блок кириллицы + диакритика), маппинг code point → индекс глифа, при необходимости — несколько атласов (по языкам или по диапазонам Юникода).

| Компонент | Работы | Оценка |
|-----------|--------|--------|
| UTF-8 декодер и обход по кодовым точкам | Как в минимальной оценке (разделы 2–4) | 4–6 чел.-дн. |
| Атлас и маппинг | Новые изображения (сетка глифов, напр. 16×N или 98 + вторая строка); конфиг или код маппинга code point → (текстура, индекс); загрузка в Font | 3–5 чел.-дн. |
| Font / шейдеры | Переменное число глифов (константа из Font или uniform), расчёт UV без захардкоженной 98; кернинг — расширенная матрица или упрощённая модель для не-ASCII | 2–3 чел.-дн. |
| FontSet / GameData | Выбор атласа по языку/локали; загрузка нескольких шрифтов (размер + язык) | 1–2 чел.-дн. |
| Truncate, WrappedText | Как в минимальной оценке | уже включено выше |
| Регрессия, подгонка вёрстки | Все экраны, длинные строки, переносы, обрезка | 2–3 чел.-дн. |

**Итого вариант A:** **12–19 человеко-дней**. Файлов: 3–4 (минимальный UTF-8) + Font.cpp/h, FontSet, GameData, шейдеры, ресурсы — **~8–12 файлов**, **~400–600 строк** кода и конфигов.

---

### Вариант B: Переход на библиотеку рендеринга (FreeType или stb_truetype)

**Суть:** заменить текущую загрузку bitmap-атласа на загрузку TTF/OTF, генерацию глифов (атлас на лету или кэш), отрисовку квадов с UV из атласа. Полная поддержка Unicode и масштабирования.

| Компонент | Работы | Оценка |
|-----------|--------|--------|
| Зависимость и сборка | Интеграция FreeType (или stb_truetype) в CMake, линковка на всех платформах | 1–2 чел.-дн. |
| Загрузка шрифтов | Чтение TTF/OTF, выбор face по размеру; замена текущего Load(путь к PNG) на Load(путь к TTF, размер) | 2–3 чел.-дн. |
| Генерация атласа / кэш глифов | Рендер глифов в текстуру (или одна большая текстура с подзагрузкой); маппинг code point → (x, y, w, h) в атласе; кернинг из FreeType | 3–5 чел.-дн. |
| Рисование и ширина | Замена DrawAliased/WidthRawString на обход по кодовым точкам, запрос глифа из кэша/атласа, расчёт advance; сохранение API Font::Draw/Width | 2–4 чел.-дн. |
| Шейдеры | UV из атласа (не один ряд 98); при необходимости разные размеры текстур | 1–2 чел.-дн. |
| FontSet / GameData | Шрифты по размеру и опционально по языку; пути к TTF вместо PNG | 0.5–1 чел.-дн. |
| Truncate, WrappedText | Адаптация под новый способ измерения ширины (уже по глифам) | 0.5–1 чел.-дн. |
| Ресурсы | Подготовка/выбор TTF для интерфейса, лицензии | 0.5–1 чел.-дн. |
| Регрессия и краевые случаи | Все экраны, производительность, артефакты | 2–4 чел.-дн. |

**Итого вариант B:** **13–23 человеко-дня**. Файлов: **~10–15** (новый модуль атласа/кэша, Font, FontSet, GameData, шейдеры, CMake, ресурсы). Строк кода: **~600–1000+** (сильно зависит от выбора кэширования и формата атласа).

---

### Вариант C: Абстракция «рендерер текста» + два бэкенда

**Суть:** ввести интерфейс (например `ITextRenderer` или абстрактный `Font`), текущий bitmap-Font оставить как один бэкенд, второй — на FreeType/stb_truetype. Выбор бэкенда по настройке или по наличию ресурсов.

| Компонент | Работы | Оценка |
|-----------|--------|--------|
| Интерфейс и фабрика | Абстрактный класс/интерфейс (Draw, Width, Height, Space), FontSet возвращает реализацию | 1–2 чел.-дн. |
| Рефакторинг текущего Font | Приведение к интерфейсу, вынос в «BitmapFont» или аналог | 1–2 чел.-дн. |
| Бэкенд на библиотеке | Как в варианте B, но в рамках интерфейса | 10–18 чел.-дн. (частично пересекается с B) |
| Конфигурация и выбор бэкенда | Настройки, автоопределение, fallback | 0.5–1 чел.-дн. |
| Регрессия | Оба бэкенда | 1–2 чел.-дн. |

**Итого вариант C:** **14–25 человеко-дней**. Файлов: **~12–18**. Даёт гибкость (старый рендерер как запасной, новый — по желанию), но увеличивает объём и поддержку двух путей.

---

## 10. Сводка по полной переработке

| Вариант | Описание | Человеко-дни | Файлов | Строк кода (ориентир) |
|---------|----------|--------------|--------|------------------------|
| **Минимальный** (разделы 1–7) | Только UTF-8 и кодовые точки, без новых глифов | 4–6 | 3–4 | ~200–270 |
| **A** | Bitmap-атласы расширенные, UTF-8, маппинг, несколько атласов/языков | 12–19 | 8–12 | ~400–600 |
| **B** | Замена на FreeType/stb_truetype, TTF/OTF, атлас/кэш глифов | 13–23 | 10–15 | ~600–1000+ |
| **C** | Абстракция рендерера + старый bitmap и новый бэкенд на библиотеке | 14–25 | 12–18 | ~700–1200+ |

**Рекомендация по порядку:** сначала минимальный этап (4–6 дн.) — корректный UTF-8 и обрезка по символам; затем при необходимости вариант A (полноценные атласы с кириллицей) или B (переход на библиотеку), без дублирования уже сделанной работы по UTF-8.
